{"version":3,"sources":["AX6UIGrid_util.js"],"names":["_jqmin","require","_AX6Util","_AX6Info","divideTableByFrozenColumnIndex","_table","_frozenColumnIndex","tempTable_l","rows","tempTable_r","r","rl","length","row","cols","c","cl","col","_jqmin2","default","extend","colStartIndex","colIndex","colEndIndex","colspan","push","leftCol","rightCol","leftData","rightData","getTableByStartEndColumnIndex","_startColumnIndex","_endColumnIndex","tempTable","getMousePosition","mouseObj","changedTouches","originalEvent","clientX","pageX","clientY","pageY","ENM","mousedown","_AX6Info2","supportTouch","mouseup","_columns","columns","_AX6Util2","deepCopy","cfg","this","config","maekRows","depth","parentField","i","l","field","hidden","rowspan","rowIndex","width","columnMinWidth","table","concat","makeBodyRowTable","selfMakeRow","__columns","makeBodyRowMap","map","forEach","makeFootSumTable","_footSumColumns","footSumRow","addC","colGroup","align","label","columnAttr","key","formatter","makeBodyGroupingTable","_bodyGroupingColumns","findPanelByColumnIndex","_dindex","_colIndex","_rowIndex","_containerPanelName","_isScrollPanel","_panels","frozenColumnIndex","xvar","frozenRowIndex","join","panelName","containerPanelName","isScrollPanel","getRealPathForDataItem","_dataPath","path","_path","split","n","replace","makeHeaderTable"],"mappings":"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","file":"AX6UIGrid_util.js","sourcesContent":["import jQuery from \"jqmin\";\nimport U from \"./AX6Util\";\nimport info from \"./AX6Info\";\n\n/**\n * @method ax5grid.util.divideTableByFrozenColumnIndex\n * @param _table\n * @param _frozenColumnIndex\n * @returns {{leftHeaderData: {rows: Array}, headerData: {rows: Array}}}\n */\nconst divideTableByFrozenColumnIndex = function (_table, _frozenColumnIndex) {\n\n    let tempTable_l = {rows: []},\n        tempTable_r = {rows: []};\n\n    for (let r = 0, rl = _table.rows.length; r < rl; r++) {\n        let row = _table.rows[r];\n\n        tempTable_l.rows[r] = {cols: []};\n        tempTable_r.rows[r] = {cols: []};\n\n        for (let c = 0, cl = row.cols.length; c < cl; c++) {\n            let col = jQuery.extend({}, row.cols[c]),\n                colStartIndex = col.colIndex,\n                colEndIndex = col.colIndex + col.colspan;\n\n            if (colStartIndex < _frozenColumnIndex) {\n                if (colEndIndex <= _frozenColumnIndex) {\n                    // 좌측편에 변형없이 추가\n                    tempTable_l.rows[r].cols.push(col);\n                } else {\n                    let leftCol = jQuery.extend({}, col),\n                        rightCol = jQuery.extend({}, leftCol);\n\n                    leftCol.colspan = _frozenColumnIndex - leftCol.colIndex;\n                    rightCol.colIndex = _frozenColumnIndex;\n                    rightCol.colspan = col.colspan - leftCol.colspan;\n\n                    tempTable_l.rows[r].cols.push(leftCol);\n                    if (rightCol.colspan) {\n                        tempTable_r.rows[r].cols.push(rightCol);\n                    }\n                }\n            }\n            else {\n                // 오른편\n                tempTable_r.rows[r].cols.push(col);\n            }\n\n            col = null;\n            colStartIndex = null;\n            colEndIndex = null;\n        }\n\n        row = null;\n    }\n\n    return {\n        leftData: tempTable_l,\n        rightData: tempTable_r\n    }\n};\n\nconst getTableByStartEndColumnIndex = function (_table, _startColumnIndex, _endColumnIndex) {\n\n    let tempTable = {rows: []};\n    for (let r = 0, rl = _table.rows.length; r < rl; r++) {\n        let row = _table.rows[r];\n\n        tempTable.rows[r] = {cols: []};\n        for (let c = 0, cl = row.cols.length; c < cl; c++) {\n            let col = jQuery.extend({}, row.cols[c]),\n                colStartIndex = col.colIndex, colEndIndex = col.colIndex + col.colspan;\n\n            if (_startColumnIndex <= colStartIndex || colEndIndex <= _endColumnIndex) {\n                if (_startColumnIndex <= colStartIndex && colEndIndex <= _endColumnIndex) {\n                    // 변형없이 추가\n                    tempTable.rows[r].cols.push(col);\n                }\n                else if (_startColumnIndex > colStartIndex && colEndIndex > _startColumnIndex) {\n                    // 앞에서 걸친경우\n                    col.colspan = colEndIndex - _startColumnIndex;\n                    tempTable.rows[r].cols.push(col);\n                }\n                else if (colEndIndex > _endColumnIndex && colStartIndex <= _endColumnIndex) {\n                    tempTable.rows[r].cols.push(col);\n                }\n            }\n        }\n    }\n\n    return tempTable;\n};\n\nconst getMousePosition = function (e) {\n    let mouseObj,\n        originalEvent = (e.originalEvent) ? e.originalEvent : e;\n\n    mouseObj = ('changedTouches' in originalEvent && originalEvent.changedTouches) ? originalEvent.changedTouches[0] : originalEvent;\n    // clientX, Y 쓰면 스크롤에서 문제 발생\n    return {\n        clientX: mouseObj.pageX,\n        clientY: mouseObj.pageY\n    }\n};\n\nconst ENM = {\n    \"mousedown\": (info.supportTouch) ? \"touchstart\" : \"mousedown\",\n    \"mousemove\": (info.supportTouch) ? \"touchmove\" : \"mousemove\",\n    \"mouseup\": (info.supportTouch) ? \"touchend\" : \"mouseup\"\n};\n\nconst makeHeaderTable = function (_columns) {\n    let columns = U.deepCopy(_columns),\n        cfg = this.config,\n        table = {\n            rows: []\n        },\n        colIndex = 0,\n        maekRows = function (_columns, depth, parentField) {\n            var row = {cols: []};\n            var i = 0, l = _columns.length;\n\n            for (; i < l; i++) {\n                var field = _columns[i];\n                var colspan = 1;\n\n                if (!field.hidden) {\n                    field.colspan = 1;\n                    field.rowspan = 1;\n\n                    field.rowIndex = depth;\n                    field.colIndex = (function () {\n                        if (!parentField) {\n                            return colIndex++;\n                        } else {\n                            colIndex = parentField.colIndex + i + 1;\n                            return parentField.colIndex + i;\n                        }\n                    })();\n\n                    row.cols.push(field);\n\n                    if ('columns' in field) {\n                        colspan = maekRows(field.columns, depth + 1, field);\n                    } else {\n                        field.width = ('width' in field) ? field.width : cfg.columnMinWidth;\n                    }\n                    field.colspan = colspan;\n                } else {\n\n\n                }\n            }\n\n            if (row.cols.length > 0) {\n                if (!table.rows[depth]) {\n                    table.rows[depth] = {cols: []};\n                }\n                table.rows[depth].cols = table.rows[depth].cols.concat(row.cols);\n                return (row.cols.length - 1) + colspan;\n            } else {\n                return colspan;\n            }\n\n        };\n\n    maekRows(columns, 0);\n\n    // set rowspan\n    for (let r = 0, rl = table.rows.length; r < rl; r++) {\n        for (let c = 0, cl = table.rows[r].cols.length; c < cl; c++) {\n            if (!('columns' in table.rows[r].cols[c])) {\n                table.rows[r].cols[c].rowspan = rl - r;\n            }\n        }\n    }\n\n    return table;\n};\n\nconst makeBodyRowTable = function (_columns) {\n    let columns = U.deepCopy(_columns),\n        table = {\n            rows: []\n        },\n        colIndex = 0,\n        maekRows = function (_columns, depth, parentField) {\n            let row = {cols: []},\n                i = 0,\n                l = _columns.length,\n                colspan = 1;\n\n            let selfMakeRow = function (__columns) {\n                let i = 0, l = __columns.length;\n                for (; i < l; i++) {\n                    let field = __columns[i],\n                        colspan = 1;\n\n                    if (!field.hidden) {\n\n                        if ('key' in field) {\n                            field.colspan = 1;\n                            field.rowspan = 1;\n\n                            field.rowIndex = depth;\n                            field.colIndex = (function () {\n                                if (!parentField) {\n                                    return colIndex++;\n                                } else {\n                                    colIndex = parentField.colIndex + i + 1;\n                                    return parentField.colIndex + i;\n                                }\n                            })();\n\n                            row.cols.push(field);\n                            if ('columns' in field) {\n                                colspan = maekRows(field.columns, depth + 1, field);\n                            }\n                            field.colspan = colspan;\n                        }\n                        else {\n                            if ('columns' in field) {\n                                selfMakeRow(field.columns, depth);\n                            }\n                        }\n                    }\n                    else {\n\n                    }\n                }\n            };\n\n            for (; i < l; i++) {\n                let field = _columns[i];\n                colspan = 1;\n\n                if (!field.hidden) {\n\n                    if ('key' in field) {\n                        field.colspan = 1;\n                        field.rowspan = 1;\n\n                        field.rowIndex = depth;\n                        field.colIndex = (function () {\n                            if (!parentField) {\n                                return colIndex++;\n                            } else {\n                                colIndex = parentField.colIndex + i + 1;\n                                return parentField.colIndex + i;\n                            }\n                        })();\n\n                        row.cols.push(field);\n                        if ('columns' in field) {\n                            colspan = maekRows(field.columns, depth + 1, field);\n                        }\n                        field.colspan = colspan;\n                    }\n                    else {\n                        if ('columns' in field) {\n                            selfMakeRow(field.columns, depth);\n                        }\n                    }\n                }\n                else {\n\n                }\n\n                field = null;\n            }\n\n            if (row.cols.length > 0) {\n                if (!table.rows[depth]) {\n                    table.rows[depth] = {cols: []};\n                }\n                table.rows[depth].cols = table.rows[depth].cols.concat(row.cols);\n                return (row.cols.length - 1) + colspan;\n            }\n            else {\n                return colspan;\n            }\n        };\n\n    maekRows(columns, 0);\n\n    (function (table) {\n        // set rowspan\n        for (let r = 0, rl = table.rows.length; r < rl; r++) {\n            let row = table.rows[r];\n            for (let c = 0, cl = row.cols.length; c < cl; c++) {\n                let col = row.cols[c];\n                if (!('columns' in col)) {\n                    col.rowspan = rl - r;\n                }\n                col = null;\n            }\n            row = null;\n        }\n    })(table);\n\n    return table;\n};\n\nconst makeBodyRowMap = function (_table) {\n    let map = {};\n    _table.rows.forEach(function (row) {\n        row.cols.forEach(function (col) {\n            map[col.rowIndex + \"_\" + col.colIndex] = jQuery.extend({}, col);\n        });\n    });\n    return map;\n};\n\nlet makeFootSumTable = function (_footSumColumns) {\n    let table = {\n        rows: []\n    };\n\n    for (let r = 0, rl = _footSumColumns.length; r < rl; r++) {\n        let footSumRow = _footSumColumns[r],\n            addC = 0;\n\n        table.rows[r] = {cols: []};\n\n        for (let c = 0, cl = footSumRow.length; c < cl; c++) {\n            if (addC > this.colGroup.length) break;\n            let colspan = footSumRow[c].colspan || 1;\n            if (footSumRow[c].label || footSumRow[c].key) {\n                table.rows[r].cols.push({\n                    colspan: colspan,\n                    rowspan: 1,\n                    colIndex: addC,\n                    columnAttr: \"sum\",\n                    align: footSumRow[c].align,\n                    label: footSumRow[c].label,\n                    key: footSumRow[c].key,\n                    collector: footSumRow[c].collector,\n                    formatter: footSumRow[c].formatter\n                });\n            } else {\n                table.rows[r].cols.push({\n                    colIndex: addC,\n                    colspan: colspan,\n                    rowspan: 1,\n                    label: \"&nbsp;\",\n                });\n            }\n            addC += colspan;\n            colspan = null;\n        }\n\n        if (addC < this.colGroup.length) {\n            for (let c = addC; c < this.colGroup.length; c++) {\n                table.rows[r].cols.push({\n                    colIndex: (c),\n                    colspan: 1,\n                    rowspan: 1,\n                    label: \"&nbsp;\",\n                });\n            }\n        }\n        footSumRow = null;\n        addC = null;\n    }\n\n    return table;\n};\n\nconst makeBodyGroupingTable = function (_bodyGroupingColumns) {\n    let table = {\n            rows: []\n        },\n        r = 0,\n        addC = 0;\n\n    table.rows[r] = {cols: []};\n    for (let c = 0, cl = _bodyGroupingColumns.length; c < cl; c++) {\n        if (addC > this.columns.length) break;\n        let colspan = _bodyGroupingColumns[c].colspan || 1;\n        if (_bodyGroupingColumns[c].label || _bodyGroupingColumns[c].key) {\n            table.rows[r].cols.push({\n                colspan: colspan,\n                rowspan: 1,\n                rowIndex: 0,\n                colIndex: addC,\n                columnAttr: \"default\",\n                align: _bodyGroupingColumns[c].align,\n                label: _bodyGroupingColumns[c].label,\n                key: _bodyGroupingColumns[c].key,\n                collector: _bodyGroupingColumns[c].collector,\n                formatter: _bodyGroupingColumns[c].formatter\n            });\n        } else {\n            table.rows[r].cols.push({\n                rowIndex: 0,\n                colIndex: addC,\n                colspan: colspan,\n                rowspan: 1,\n                label: \"&nbsp;\"\n            });\n        }\n        addC += colspan;\n    }\n\n    if (addC < this.colGroup.length) {\n        for (var c = addC; c < this.colGroup.length; c++) {\n            table.rows[r].cols.push({\n                rowIndex: 0,\n                colIndex: (c),\n                colspan: 1,\n                rowspan: 1,\n                label: \"&nbsp;\",\n            });\n        }\n    }\n\n    return table;\n};\n\nconst findPanelByColumnIndex = function (_dindex, _colIndex, _rowIndex) {\n    let _containerPanelName,\n        _isScrollPanel = false,\n        _panels = [];\n\n    if (this.xvar.frozenRowIndex > _dindex) _panels.push(\"top\");\n    if (this.xvar.frozenColumnIndex > _colIndex) _panels.push(\"left\");\n    _panels.push(\"body\");\n\n    if (this.xvar.frozenColumnIndex <= _colIndex || this.xvar.frozenRowIndex <= _dindex) {\n        _containerPanelName = _panels.join(\"-\");\n        _panels.push(\"scroll\");\n        _isScrollPanel = true;\n    }\n\n    return {\n        panelName: _panels.join(\"-\"),\n        containerPanelName: _containerPanelName,\n        isScrollPanel: _isScrollPanel\n    }\n};\n\nconst getRealPathForDataItem = function (_dataPath) {\n    let path = [],\n        _path = [].concat(_dataPath.split(/[\\.\\[\\]]/g));\n\n    _path.forEach(function (n) {\n        if (n !== \"\") path.push(\"[\\\"\" + n.replace(/['\\\"]/g, \"\") + \"\\\"]\");\n    });\n    _path = null;\n    return path.join(\"\");\n};\n\nexport default {\n    divideTableByFrozenColumnIndex: divideTableByFrozenColumnIndex,\n    getTableByStartEndColumnIndex: getTableByStartEndColumnIndex,\n    getMousePosition: getMousePosition,\n    ENM: ENM,\n    makeHeaderTable: makeHeaderTable,\n    makeBodyRowTable: makeBodyRowTable,\n    makeBodyRowMap: makeBodyRowMap,\n    makeFootSumTable: makeFootSumTable,\n    makeBodyGroupingTable: makeBodyGroupingTable,\n    findPanelByColumnIndex: findPanelByColumnIndex,\n    getRealPathForDataItem: getRealPathForDataItem\n};"]}